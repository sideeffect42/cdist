#!/bin/sh -e
#
# 2014 Steven Armstrong (steven-cdist at armstrong.cc)
#
# This file is part of cdist.
#
# cdist is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# cdist is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with cdist. If not, see <http://www.gnu.org/licenses/>.
#

set -e -u

# validate key (does the format resemble a SSH pubkey?)
if grep -q '\(ssh\|ecdsa\)-[^ ]\{1,\} [A-Za-z0-9+/=]\{1,\}' "${__object}/parameter/key"
then
   printf 'Key is invalid: "%s"\n' "$(cat "${__object}/parameter/key")" >&2
   exit 1
fi

remove_line() {
   file="$1"
   line="$2"
   cat << DONE
tmpfile=\$(mktemp ${file}.cdist.XXXXXXXXXX)
# preserve ownership and permissions of existing file
if [ -f "$file" ]; then
   cp -p "$file" "\$tmpfile"
fi
grep -v -F -x '$line' '$file' > \$tmpfile || true
mv -f "\$tmpfile" "$file"
DONE
}

add_line() {
	file="$1"
	line="$2"

	# escape single quotes
	line_sanitised=$(echo "$line" | sed -e "s/'/'\"'\"'/g")

	cat <<-EOF
	test -f '${file}' || {
	    :>'${file}'
	    chmod 0600 '${file}'
	}

	printf '%s\n' '${line_sanitised}' >>'${file}'
	EOF
}


file="$(cat "$__object/parameter/file")"
mkdir "$__object/files"

# Generate the entry as it should be
(
   if [ -f "$__object/parameter/option" ]; then
      # comma seperated list of options
      options="$(tr '\n' ',' < "$__object/parameter/option")"
      printf '%s ' "${options%*,}"
   fi
   if [ -f "$__object/parameter/comment" ]; then
      # extract the keytype and base64 encoded key without options and comment.
      # Then, override the comment with the one explicitly given.
      printf '%s %s' \
         "$(grep -q '\(ssh\|ecdsa\)-[^ ]\{1,\} [A-Za-z0-9+/=]\{1,\}' "${__object}/parameter/key")" \
         "$(cat "${__object}/parameter/comment")"
   else
      printf '%s' "$(cat "${__object}/parameter/key")"
   fi
   printf '\n'
) > "$__object/files/should"

# Remove conflicting entries if any
if [ -s "$__object/explorer/entry" ]; then
   # NOTE: the files have to be sorted for comparison with `comm`.
   sort "$__object/explorer/entry" \
   | comm -13 "$__object/files/should" - \
   | while read -r entry; do
        remove_line "$file" "$entry"
     done
fi

# Determine the current state
entry="$(cat "$__object/files/should")"
state_should="$(cat "$__object/parameter/state")"
num_existing_entries=$(grep -c -x -F "$entry" "$__object/explorer/entry" || true)
if [ "$num_existing_entries" -eq 1 ]; then
   state_is="present"
else
   # Posix grep does not define the -m option, so we can not remove a single
   # occurence of a string from a file in the `remove_line` function. Instead
   # _all_ occurences are removed.
   # By using `comm` to detect conflicting entries this could lead to the
   # situation that the key we want to add is actually removed.
   # To workaround this we must treat 0 or more than 1 existing entries to
   # mean current state is 'absent'. By doing this, the key is readded
   # again after cleaning up conflicting entries.
   state_is="absent"
fi

# Manage the actual entry as it should be
if [ "$state_should" = "$state_is" ]; then
   # Nothing to do
   exit 0
fi

case "$state_should" in
   present)
      add_line "$file" "$entry"
      echo "added to $file ($entry)" >> "$__messages_out"
   ;;
   absent)
      remove_line "$file" "$entry"
      echo "removed from $file ($entry)" >> "$__messages_out"
   ;;
esac
